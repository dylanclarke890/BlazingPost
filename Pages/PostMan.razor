@page "/post"
@using BlazingPostMan.Shared.Tab;
@inject IRequestProcessor requestProcessor

<h3>BlazingPostMan</h3>

<div class="form-group row">
    <label class="col-2 col-form-label" for="url-input">Enter a URL: </label>
    <input class="col-10 form-control" id="url-input" type="text" @bind="Url" />
</div>

<div class="form-group">
    <label>Request Type: </label>
    <select @bind="requestType">
        <option value="@RequestType.POST">@RequestType.POST</option>
        <option value="@RequestType.GET">@RequestType.GET</option>
        <option value="@RequestType.PUT">@RequestType.PUT</option>
        <option value="@RequestType.DELETE">@RequestType.DELETE</option>
    </select>
</div>

<div class="mt-3 mb-3">
    <h3>Preview: </h3> <span>@requestType @UrlHelper.GetUrl(Url, Params)</span><br />
</div>

<button class="btn btn-primary" @onclick="SendRequest" disabled="@sending">Send</button>

<div class="mt-3 mb-3">
    <h3>Result:</h3>
    <div>@requestResult</div>
</div>

<TabSet>
    <TabChild Title="Params">
        <KeyValuesTable Title="Add Parameters" KeyValuePairs="Params" OnAction="StateHasChanged"
                        WhiteSpaceAllowedInKey="true" MonitorKeys="QueryKeysToNotifyOf" OnMonitoredKeyActioned="HandleMonitoredKeyValue" />
    </TabChild>
    <TabChild Title="Body">
        <BodyContent Body="RequestBody" OnBodyUpdated="(b) => RequestBody = b"/>
    </TabChild>
    <TabChild Title="Headers">
        <KeyValuesTable Title="Add Headers" KeyValuePairs="Headers" OnAction="StateHasChanged" 
                        WhiteSpaceAllowedInKey="false" MonitorKeys="HeaderKeysToNotifyOf" OnMonitoredKeyActioned="HandleMonitoredKeyValue" />
    </TabChild>
    <TabChild Title="Authorisation">
        <Authorisation AuthorisationData="AuthorisationData" OnAuthorisationUpdated="HandleAuthUpdate"/>
    </TabChild>
</TabSet>

@code {
    private string Url { get; set; } = "https://localhost:44384/api/testendpoint";
    private RequestType requestType { get; set; }

    private Dictionary<string, string> Params = new() { ["test key"] = "this is a test val" };
    private Dictionary<string, string> Headers = new() { ["key"] = "this is a test val" };
    private List<string> HeaderKeysToNotifyOf = new() { "ApiKey", "Authorisation", "Authorization" };
    private List<string> QueryKeysToNotifyOf = new() { "ApiKey", "Authorisation", "Authorization" };
    private Body RequestBody;
    private AuthorisationData AuthorisationData = new();

    private string requestResult;

    private bool sending = false;

    private async Task SendRequest()
    {
        sending = true;
        var result = await requestProcessor.ProcessRequest(new(Url, requestType, Params, Headers, RequestBody, AuthorisationData));
        await HandleContent(result);
        sending = false;
    }

    private void HandleMonitoredKeyValue(KeyValuePair<string, string> keyValue)
    {
        switch (keyValue.Key)
        {
            case "ApiKey":
                AuthorisationData ??= new();
                AuthorisationData.AuthorisationType = AuthorisationType.ApiKey;
                AuthorisationData.Key = keyValue.Key;
                AuthorisationData.Value = keyValue.Value;
                break;
            case "Authorisation":
                AuthorisationData ??= new();
                AuthorisationData.AuthorisationType = AuthorisationType.BearerToken;

                if (AuthorisationData.RelatedSection is Section.Headers && keyValue.Value is null)
                {
                    RemoveExistingAuthFromSection(Section.Headers);
                }
                else
                {
                    AuthorisationData.BearerToken = keyValue.Value;
                }
                break;
            default:
                break;
        }
    }

    private bool EmptyOrNullApiKey(AuthorisationData authorisationData) =>
        string.IsNullOrEmpty(authorisationData.Key) || string.IsNullOrEmpty(authorisationData.Value);

    private void HandleAuthUpdate(AuthorisationData authorisationData)
    {
        if (authorisationData.AuthorisationType is AuthorisationType.NoAuth)
        {
            RemoveExistingAuthFromSection(Section.Authorisation);
            return;
        }

        if (authorisationData.RelatedSection is Section.Params && !EmptyOrNullApiKey(authorisationData))
        {
            RemoveExistingAuthFromSection(Section.Headers);
            Params.TryAdd(authorisationData.Key, authorisationData.Value);
        }
        else if (authorisationData.RelatedSection is Section.Headers && !EmptyOrNullApiKey(authorisationData))
        {
            RemoveExistingAuthFromSection(Section.Params);
            Headers.TryAdd(authorisationData.Key, authorisationData.Value);
        }
        else if (authorisationData.RelatedSection is Section.Headers && !string.IsNullOrEmpty(authorisationData.BearerToken))
        {
            RemoveExistingAuthFromSection(Section.Params);
            Headers.TryAdd("Authorisation", authorisationData.BearerToken);
        }

        AuthorisationData = authorisationData;
    }

    private void RemoveExistingAuthFromSection(Section section)
    {
        switch (section)
        {
            case Section.Params:

                Params.TryRemove(AuthorisationData?.Key);
                break;

            case Section.Headers:

                Headers.TryRemove(AuthorisationData?.Key);
                Headers.TryRemove("Authorisation");

                break;

            case Section.Authorisation:

                Params.TryRemove(AuthorisationData?.Key);
                Headers.TryRemove(AuthorisationData?.Key);
                Headers.TryRemove("Authorisation");

                break;

            default:
                break;
        }
    }

    private async Task HandleContent(HttpResponseMessage response)
    {
        requestResult = await response.Content.ReadAsStringAsync();
    }
}

<style>
    .hand {
        cursor: pointer;
    }
</style>